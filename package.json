{
	"name": "agent-memory",
	"publisher": "digitarald",
	"displayName": "Agent Memory",
	"description": "Memory tool implementation for VS Code. Store and retrieve context across conversations.",
	"repository": {
		"type": "git",
		"url": "https://github.com/Microsoft/vscode-extension-samples"
	},
	"version": "0.1.0",
	"license": "MIT",
	"engines": {
		"vscode": "^1.105.0"
	},
	"categories": [
		"AI",
		"Chat"
	],
	"activationEvents": [],
	"contributes": {
		"languageModelTools": [
			{
				"name": "memory",
				"tags": [
					"memory",
					"context",
					"agent-memory"
				],
				"toolReferenceName": "memory",
				"displayName": "Memory",
				"modelDescription": "Enables storing and retrieving information across conversations through a persistent memory file directory. This tool allows you to create, read, update, and delete files in the /memories directory that persist between sessions, allowing you to build knowledge over time without keeping everything in the context window. Use this tool to maintain project context across multiple executions, learn from past interactions and decisions, build knowledge bases over time, and enable cross-conversation learning where you can improve at recurring workflows. IMPORTANT: ALWAYS view your memory directory before doing anything else to check for earlier progress. As you make progress on tasks, record status, progress, and thoughts in your memory. Assume your context window might be reset at any moment, so you risk losing any progress that is not recorded in your memory directory. When editing your memory folder, always try to keep its content up-to-date, coherent and organized. You can rename or delete files that are no longer relevant. Do not create new files unless necessary. All operations are restricted to the /memories directory for security.",
				"canBeReferencedInPrompt": true,
				"icon": "$(database)",
				"inputSchema": {
					"type": "object",
					"properties": {
						"command": {
							"type": "string",
							"enum": [
								"view",
								"create",
								"str_replace",
								"insert",
								"delete",
								"rename"
							],
							"description": "The memory operation to perform. 'view' shows directory contents or reads file contents (optionally with line ranges). 'create' creates a new file or overwrites an existing file with the provided content. 'str_replace' replaces the first occurrence of old_str with new_str in a file. 'insert' inserts text at a specific line number (1-indexed). 'delete' removes a file or recursively deletes a directory. 'rename' moves or renames a file or directory to a new path."
						},
						"path": {
							"type": "string",
							"description": "The absolute path to the file or directory within the /memories directory. Must start with /memories/ to ensure security. Used for view, create, str_replace, insert, and delete commands. For view commands on directories, this returns the list of files and subdirectories. For view commands on files, this returns the file contents (optionally filtered by view_range). This path is validated to prevent directory traversal attacks."
						},
						"view_range": {
							"type": "array",
							"items": {
								"type": "number"
							},
							"minItems": 2,
							"maxItems": 2,
							"description": "Optional parameter for the view command that specifies which lines to read from a file. Must be an array of exactly two numbers: [start_line, end_line], where both are 1-indexed line numbers (inclusive). For example, [1, 10] reads the first 10 lines. Use this when you only need to see a portion of a large file rather than loading the entire contents. Only applicable when viewing files, not directories."
						},
						"file_text": {
							"type": "string",
							"description": "The complete content to write to the file when using the create command. This will create a new file if it doesn't exist, or completely overwrite an existing file with the new content. The content should be the full text you want the file to contain after the operation completes. Use newline characters (\n) to create multi-line files. Required parameter for the create command."
						},
						"old_str": {
							"type": "string",
							"description": "The exact text string to find and replace when using the str_replace command. This must match the text in the file character-for-character, including whitespace, indentation, and newlines. Only the first occurrence of this string will be replaced. If the string is not found in the file, the operation will fail. Use this for making targeted edits to specific portions of a file without rewriting the entire file. Required parameter for the str_replace command."
						},
						"new_str": {
							"type": "string",
							"description": "The replacement text that will replace the first occurrence of old_str when using the str_replace command. This can be any string, including an empty string (to delete text), multi-line text, or text with different formatting than the original. The replacement happens exactly once per command invocation. Required parameter for the str_replace command."
						},
						"insert_line": {
							"type": "number",
							"description": "The 1-indexed line number where text should be inserted when using the insert command. The new text will be inserted at this line position, shifting existing content down. For example, insert_line=1 inserts at the beginning of the file, insert_line=5 inserts before the current line 5. If the line number is greater than the number of lines in the file, the text will be appended at the end. Required parameter for the insert command."
						},
						"insert_text": {
							"type": "string",
							"description": "The text content to insert at the specified line when using the insert command. This text will be inserted at the line specified by insert_line, pushing existing content down. Include newline characters (\n) if you want to insert multiple lines. The inserted text does not automatically include a trailing newline unless you explicitly add one. Required parameter for the insert command."
						},
						"old_path": {
							"type": "string",
							"description": "The current absolute path of the file or directory to rename/move when using the rename command. Must start with /memories/ for security. This path must exist or the operation will fail. Can be used to rename a file in place (changing only the filename) or to move a file to a different directory within /memories. Required parameter for the rename command."
						},
						"new_path": {
							"type": "string",
							"description": "The new absolute path for the file or directory when using the rename command. Must start with /memories/ for security. If a file already exists at this path, it will be overwritten. Any parent directories in the path will be created automatically if they don't exist. Use this to rename files, move files between directories, or reorganize your memory directory structure. Required parameter for the rename command."
						}
					},
					"required": [
						"command"
					],
					"allOf": [
						{
							"if": {
								"properties": {
									"command": {
										"const": "view"
									}
								}
							},
							"then": {
								"required": [
									"path"
								]
							}
						},
						{
							"if": {
								"properties": {
									"command": {
										"const": "create"
									}
								}
							},
							"then": {
								"required": [
									"path",
									"file_text"
								]
							}
						},
						{
							"if": {
								"properties": {
									"command": {
										"const": "str_replace"
									}
								}
							},
							"then": {
								"required": [
									"path",
									"old_str",
									"new_str"
								]
							}
						},
						{
							"if": {
								"properties": {
									"command": {
										"const": "insert"
									}
								}
							},
							"then": {
								"required": [
									"path",
									"insert_line",
									"insert_text"
								]
							}
						},
						{
							"if": {
								"properties": {
									"command": {
										"const": "delete"
									}
								}
							},
							"then": {
								"required": [
									"path"
								]
							}
						},
						{
							"if": {
								"properties": {
									"command": {
										"const": "rename"
									}
								}
							},
							"then": {
								"required": [
									"old_path",
									"new_path"
								]
							}
						}
					]
				}
			}
		],
		"configuration": {
			"title": "Agent Memory",
			"properties": {
				"agentMemory.storageBackend": {
					"type": "string",
					"enum": [
						"memory",
						"disk",
						"secret"
					],
					"enumDescriptions": [
						"Store memory files in-memory (per workspace, ephemeral)",
						"Store memory files in .vscode/memory directory (persistent)",
						"Store memory files encrypted in VS Code's secret storage (secure, persistent)"
					],
					"default": "memory",
					"description": "Storage backend for memory files"
				},
				"agentMemory.autoSyncToFile": {
					"type": "string",
					"default": "",
					"markdownDescription": "Automatically sync all memory files to a file in the workspace as memory changes. Provide a relative path like `AGENTS.md` or `.github/copilot/memory.instructions.md`. Leave empty to disable auto-sync.",
					"examples": [
						"AGENTS.md",
						".github/copilot/memory.instructions.md"
					]
				}
			}
		},
		"views": {
			"explorer": [
				{
					"id": "agentMemory.files",
					"name": "Memory",
					"icon": "$(database)",
					"contextualTitle": "Agent Memory"
				},
				{
					"id": "agentMemory.activityLog",
					"name": "Memory Log",
					"icon": "$(list-ordered)",
					"contextualTitle": "Agent Memory"
				}
			]
		},
		"viewsWelcome": [
			{
				"view": "agentMemory.files",
				"contents": "No memory files yet.\nMemory files are created when AI agents use the memory tool to store information.\n[Refresh](command:agentMemory.refresh)"
			},
			{
				"view": "agentMemory.activityLog",
				"contents": "No activity yet.\nActivity will appear here when AI agents interact with the memory tool.\n[Clear Logs](command:agentMemory.clearLogs)"
			}
		],
		"commands": [
			{
				"command": "agentMemory.refresh",
				"title": "Refresh Memory Files",
				"category": "Agent Memory",
				"icon": "$(refresh)"
			},
			{
				"command": "agentMemory.clearLogs",
				"title": "Clear Activity Logs",
				"category": "Agent Memory",
				"icon": "$(clear-all)"
			},
			{
				"command": "agentMemory.clearAllMemoryFiles",
				"title": "Clear All Memory Files",
				"category": "Agent Memory",
				"icon": "$(trash)"
			},
			{
				"command": "agentMemory.deleteMemoryFile",
				"title": "Delete Memory File",
				"category": "Agent Memory",
				"icon": "$(trash)"
			},
			{
				"command": "agentMemory.openMemoryFile",
				"title": "Open Memory File",
				"category": "Agent Memory"
			},
			{
				"command": "agentMemory.pinFile",
				"title": "Pin File",
				"category": "Agent Memory",
				"icon": "$(pin)"
			},
			{
				"command": "agentMemory.unpinFile",
				"title": "Unpin File",
				"category": "Agent Memory",
				"icon": "$(pinned)"
			},
			{
				"command": "agentMemory.saveAsMarkdown",
				"title": "Save as Markdown",
				"category": "Agent Memory",
				"icon": "$(save)"
			}
		],
		"menus": {
			"view/title": [
				{
					"command": "agentMemory.refresh",
					"when": "view == agentMemory.files",
					"group": "navigation"
				},
				{
					"command": "agentMemory.clearAllMemoryFiles",
					"when": "view == agentMemory.files && agentMemory.hasFiles",
					"group": "navigation"
				},
				{
					"command": "agentMemory.clearLogs",
					"when": "view == agentMemory.activityLog",
					"group": "navigation"
				}
			],
			"view/item/context": [
				{
					"command": "agentMemory.pinFile",
					"when": "view == agentMemory.files && viewItem == memoryFile",
					"group": "inline"
				},
				{
					"command": "agentMemory.unpinFile",
					"when": "view == agentMemory.files && viewItem == memoryFilePinned",
					"group": "inline"
				},
				{
					"command": "agentMemory.pinFile",
					"when": "view == agentMemory.files && viewItem == memoryDirectory",
					"group": "inline"
				},
				{
					"command": "agentMemory.unpinFile",
					"when": "view == agentMemory.files && viewItem == memoryDirectoryPinned",
					"group": "inline"
				},
				{
					"command": "agentMemory.deleteMemoryFile",
					"when": "view == agentMemory.files && viewItem == memoryFile",
					"group": "inline"
				},
				{
					"command": "agentMemory.saveAsMarkdown",
					"when": "view == agentMemory.files && viewItem == memoryFile",
					"group": "export"
				},
				{
					"command": "agentMemory.saveAsMarkdown",
					"when": "view == agentMemory.files && viewItem == memoryFilePinned",
					"group": "export"
				}
			]
		}
	},
	"main": "./out/extension.js",
	"scripts": {
		"vscode:prepublish": "npm run compile",
		"compile": "tsc -p ./",
		"lint": "eslint",
		"watch": "tsc -watch -p ./",
		"test": "jest",
		"test:watch": "jest --watch",
		"test:coverage": "jest --coverage",
		"package": "vsce package",
		"publish": "vsce publish"
	},
	"devDependencies": {
		"@eslint/js": "^9.13.0",
		"@stylistic/eslint-plugin": "^2.9.0",
		"@types/jest": "^30.0.0",
		"@types/node": "^22",
		"@types/vscode": "^1.100.0",
		"@vscode/vsce": "^3.6.2",
		"eslint": "^9.13.0",
		"jest": "^30.2.0",
		"ts-jest": "^29.4.4",
		"typescript": "^5.9.2",
		"typescript-eslint": "^8.39.0"
	}
}
